name: Docker Integration Tests

on:
  pull_request:
    paths:
      - 'backend/Dockerfile'
      - 'frontend/Dockerfile'
      - 'docker-compose.yml'
      - 'pyproject.toml'
      - 'uv.lock'
      - 'frontend/nginx.conf'
      - '.github/workflows/docker-test.yml'
  push:
    branches:
      - main
    paths:
      - 'backend/Dockerfile'
      - 'frontend/Dockerfile'
      - 'docker-compose.yml'

jobs:
  docker-integration-test:
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Docker images
        run: docker compose build --no-cache

      - name: Start services
        run: docker compose up -d

      # Step 1: Test backend independently (from inside container network)
      - name: Wait for backend health (internal)
        run: |
          echo "Waiting for backend to be healthy (testing from inside container network)..."
          for i in {1..60}; do
            if docker compose exec -T backend python -c "import urllib.request; urllib.request.urlopen('http://localhost:5000/api/system/health')" > /dev/null 2>&1; then
              echo "✅ Backend is healthy"
              break
            fi
            if [ $i -eq 60 ]; then
              echo "❌ Backend health check timeout"
              docker compose logs backend
              exit 1
            fi
            sleep 1
          done

      - name: Verify backend health response (internal)
        run: |
          RESPONSE=$(docker compose exec -T backend python -c "import urllib.request; print(urllib.request.urlopen('http://localhost:5000/api/system/health').read().decode())")
          echo "Backend health response: $RESPONSE"
          echo "$RESPONSE" | jq -e '.status == "healthy" and .database == "connected"' || exit 1

      - name: Verify backend version endpoint (internal)
        run: |
          RESPONSE=$(docker compose exec -T backend python -c "import urllib.request; print(urllib.request.urlopen('http://localhost:5000/api/system/version').read().decode())")
          echo "Backend version response: $RESPONSE"
          echo "$RESPONSE" | jq -e '.version != null' || exit 1

      # Step 2: Test frontend serves static content
      - name: Wait for frontend to serve content
        run: |
          echo "Waiting for frontend to serve static content..."
          for i in {1..60}; do
            if curl -f -s http://localhost/ > /dev/null 2>&1; then
              echo "✅ Frontend is serving content"
              break
            fi
            if [ $i -eq 60 ]; then
              echo "❌ Frontend timeout"
              docker compose logs frontend
              exit 1
            fi
            sleep 1
          done

      - name: Verify frontend index page loads
        run: |
          curl -f http://localhost/ > /dev/null || exit 1
          echo "Frontend index page loads successfully"

      # Step 3: Test frontend-backend integration (API proxy)
      - name: Test API proxy through frontend
        run: |
          RESPONSE=$(curl -s http://localhost/api/system/health)
          echo "Proxied health response: $RESPONSE"
          echo "$RESPONSE" | jq -e '.status == "healthy"' || exit 1

      - name: Test version endpoint through proxy
        run: |
          RESPONSE=$(curl -s http://localhost/api/system/version)
          echo "Proxied version response: $RESPONSE"
          echo "$RESPONSE" | jq -e '.version != null' || exit 1

      - name: Check backend container logs
        if: failure()
        run: |
          echo "=== Backend Logs ==="
          docker compose logs backend

      - name: Check frontend container logs
        if: failure()
        run: |
          echo "=== Frontend Logs ==="
          docker compose logs frontend

      - name: Cleanup
        if: always()
        run: docker compose down -v

  docker-custom-hostname-test:
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Create custom docker-compose override
        run: |
          cat > docker-compose.override.yml <<EOF
          services:
            backend:
              container_name: custom-backend-name
            frontend:
              build:
                args:
                  - BACKEND_HOST=custom-backend-name
              environment:
                - BACKEND_HOST=custom-backend-name
          EOF
          cat docker-compose.override.yml

      - name: Build with custom backend hostname
        run: docker compose build

      - name: Start services with custom hostname
        run: docker compose up -d

      - name: Wait for backend health (internal)
        run: |
          echo "Testing backend with custom container name..."
          for i in {1..60}; do
            if docker compose exec -T backend python -c "import urllib.request; urllib.request.urlopen('http://localhost:5000/api/system/health')" > /dev/null 2>&1; then
              echo "✅ Backend is healthy"
              break
            fi
            if [ $i -eq 60 ]; then
              echo "❌ Backend health check timeout"
              docker compose logs backend
              exit 1
            fi
            sleep 1
          done

      - name: Test frontend proxy with custom backend name
        run: |
          RESPONSE=$(curl -s http://localhost/api/system/health)
          echo "Proxied health response: $RESPONSE"
          echo "$RESPONSE" | jq -e '.status == "healthy"' || exit 1

      - name: Check backend logs on failure
        if: failure()
        run: docker compose logs backend

      - name: Check frontend logs on failure
        if: failure()
        run: docker compose logs frontend

      - name: Cleanup
        if: always()
        run: docker compose down -v
